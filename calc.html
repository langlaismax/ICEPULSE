<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Curling Strategy Calculator â€” Single Column + Better Highlights</title>
<style>
  :root{
    --bg:#f6f8fa; --card:#fff; --muted:#6b7280; --text:#111827;
    --accent:#0f6fff; --accent-2:#1fb6ff; --card-pad:14px; --radius:10px;
  }
  body{margin:18px; font-family:Inter,system-ui,Arial; background:linear-gradient(180deg,var(--bg),#f2f4f6); color:var(--text)}
  .wrap{max-width:1180px;margin:0 auto}
  header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
  .logo{display:flex;align-items:center;gap:10px;background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#fff;padding:8px 12px;border-radius:10px}
  .logo h1{margin:0;font-size:1rem}
  .muted{color:var(--muted)}
  .card{background:var(--card);border-radius:10px;padding:14px;margin-bottom:12px;box-shadow:0 6px 18px rgba(15,23,42,0.06);border:1px solid rgba(15,23,42,0.04)}
  .controls{display:flex;flex-wrap:wrap;gap:12px;align-items:end}
  .control{display:flex;flex-direction:column}
  label{font-size:0.78rem;color:var(--muted);margin-bottom:6px}
  select,input,button{padding:8px;border-radius:8px;border:1px solid #e6e8eb;background:#fff;font-size:0.95rem}
  select[multiple]{min-height:82px}
  .w-110{width:110px}.w-160{width:160px}.w-180{width:180px}.w-200{width:200px}.w-240{width:240px}
  .btn{padding:8px 12px;border-radius:8px;border:1px solid #e6e8eb;background:#fff;cursor:pointer}
  .btn-primary{background:var(--accent);color:#fff;border:none;box-shadow:0 6px 20px rgba(15,111,255,0.12)}
  #constraints{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:12px}
  @media(max-width:1000px){#constraints{grid-template-columns:repeat(3,1fr)}}
  @media(max-width:700px){#constraints{grid-template-columns:repeat(2,1fr)}}
  .task-card{padding:10px;border-radius:8px;border:1px solid #f0f2f4;background:linear-gradient(180deg,#fff,#fbfdff)}
  .task-title{font-weight:700;margin-bottom:8px}
  table{width:100%;border-collapse:collapse;margin-top:12px;font-size:0.92rem}
  thead th{background:linear-gradient(180deg,#f8fafc,#fff);position:sticky;top:0;padding:10px;text-align:left;color:var(--muted)}
  td,th{padding:8px 10px;border-bottom:1px solid #f0f2f4}
  .center{text-align:center}
  .swatch{width:160px;height:14px;border-radius:6px;background:linear-gradient(90deg,hsl(0,78%,45%),hsl(60,78%,45%),hsl(120,78%,45%))}
  .progress-wrap{height:14px;background:#eef2f7;border-radius:10px;margin-top:10px;overflow:hidden;border:1px solid #eef3fb;display:none}
  .progress-bar{height:100%;background:linear-gradient(90deg,var(--accent),var(--accent-2));width:0%;color:white;font-size:11px;display:flex;align-items:center;justify-content:center}
  /* new highlight cell styles */
  .cell-best-est{background:linear-gradient(90deg,#ffe5b4,#ffcf6b);color:#111;font-weight:700;border-radius:6px}
  .cell-best-player{background:linear-gradient(90deg,#bff3d0,#50d88a);color:#022;font-weight:700;border-radius:6px}
  .muted-xs{color:var(--muted);font-size:0.86rem}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="logo"><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M12 2l3.5 7H8.5L12 2zM4 21h16l-8-8-8 8z" fill="white"/></svg><h1>Curling Strategy Calculator</h1></div>
    <div class="muted" style="margin-left:auto">Tip: hold Ctrl/Cmd to multi-select</div>
  </header>

  <!-- controls & results (single column layout) -->
  <section class="card">
    <h2>Analysis Controls</h2>

    <div class="controls" style="margin-bottom:8px">
	  <div class="control w-110" style="align-self:flex-end"><label>&nbsp;</label><button id="analyzeBtn" class="btn btn-primary">Analyze</button></div>
  	  <div class="control w-200"><label>Player</label><select id="playerSelect"><option value="">-- none --</option></select></div>
      <div class="control w-110"><label>Evaluate shot</label><select id="evalPos"></select></div>
      <div class="control w-160"><label>Start date</label><input id="startDate" type="date" /></div>
      <div class="control w-160"><label>End date</label><input id="endDate" type="date" /></div> 
	  <div class="control w-240"><label>Minimum Popularity</label><div style="display:flex;gap:8px;align-items:center"><input id="supportSlider" type="range" min="0" max="5" step="0.1" value="0.1" /><div id="supportVal" style="min-width:64px;text-align:center;font-weight:600">0.1%</div></div></div>
    </div>

    <div class="controls" style="margin-bottom:8px">
	  <div class="control w-180"><label>Ends Left (multi)</label><select id="endsLeftSelect" multiple></select></div>
      <div class="control w-200"><label>Gender (multi)</label><select id="genderSelect" multiple><option value="Any">Any</option><option>Men</option><option>Women</option><option>Mixed</option></select></div>
      <div class="control w-240"><label>Category (multi)</label><select id="categorySelect" multiple><option value="Any">Any</option><option>Olympics</option><option>Worlds</option><option>Brier</option><option>Scotties</option><option>Euros</option><option>CIS</option><option>U Sports</option><option>Canadian Jrs</option><option>Canadian U-18s</option><option>Pacific-Asia</option><option>Jr Worlds</option><option>Grand Slams</option><option>OQE</option></select></div>

      <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
        <button id="downloadBtn" class="btn">Export CSV</button>
        <button id="toggleViewBtn" class="btn">Expanded View</button>
      </div>
    </div>

    <div class="progress-wrap" id="progressWrap"><div class="progress-bar" id="progressBar">0%</div></div>

    <div id="results" style="margin-top:12px"></div>

    <div class="muted-xs" style="margin-top:12px">Results update when you click Analyze. Use Expanded View to see breakdown and edit player defaults.</div>
  </section>

  <!-- Player defaults card (used for editing and also now populated when player selected) -->
  <section class="card" id="playerDefaultsPanel" style="display:none;margin-top:12px">
    <h2>Player Defaults</h2>
    <div class="muted-xs">If a player is selected, these inputs will be filled with that player's stats</div>
    <div style="display:flex;gap:8px;margin-top:10px">
      <input id="defaultsName" placeholder="Defaults name (optional)" style="flex:1;padding:8px;border-radius:8px;border:1px solid #eef2f7"/>
      <button id="resetDefaultsBtn" class="btn">Reset</button>
    </div>

    <div id="defaultsGrid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:12px"></div>
  </section>

  <!-- shot selection (bottom) -->
  <section class="card" style="margin-top:12px">
    <h2>Shot selection</h2>
    <div id="constraints"></div>
  </section>
</div>

<script>
/* ========== Config & small helpers ========== */
const AVAILABLE_SUMMARIES = [
  "data/summary_2001.json","data/summary_2002.json","data/summary_2003.json","data/summary_2004.json",
  "data/summary_2005.json","data/summary_2006.json","data/summary_2007.json","data/summary_2008.json",
  "data/summary_2009.json","data/summary_2010.json","data/summary_2011.json","data/summary_2012.json",
  "data/summary_2013.json","data/summary_2014.json","data/summary_2015.json","data/summary_2016_part1.json",
  "data/summary_2016_part2.json","data/summary_2017_part1.json","data/summary_2017_part2.json","data/summary_2017_part3.json",
  "data/summary_2018_part1.json","data/summary_2018_part2.json","data/summary_2019_part1.json","data/summary_2019_part2.json",
  "data/summary_2020.json","data/summary_2021_part1.json","data/summary_2021_part2.json","data/summary_2022_part1.json",
  "data/summary_2022_part2.json","data/summary_2023_part1.json","data/summary_2023_part2.json","data/summary_2023_part3.json",
  "data/summary_2024_part1.json","data/summary_2024_part2.json","data/summary_2025.json"
];

const TASK_OPTIONS = ["Any","Draw","Guard","Front","Take-out","Hit-roll","Double","Raise","Freeze","Clearing","Through","Wick","Promotion"];
const TURN_OPTIONS = ["Any","CW","CCW"];
const BUCKETS = ['-3+','-2','-1','0','1','2','3+'];
const BUCKET_VAL = {'-3+': -3,'-2': -2,'-1': -1,'0':0,'1':1,'2':2,'3+':3};

let mergedAll = [], byYearMap = {}, playerStatsObj = null;

/* --- CATEGORY ALIASES (add more synonyms here as needed) --- */
const CATEGORY_ALIASES = {
  "Grand Slams": ["grand slam","grand slams","grand-slam","grandslam","grand-slam(s)"],
  "Olympics": ["olympic","olympics","winter olympics"],
  "Worlds": ["world championship","worlds","world championships","worlds championship"],
  "Brier": ["brier"],
  "Scotties": ["scotties","scotties tournament","scotties tournament of hearts","tournament of hearts"],
  "Euros": ["european","euros","europeans","european championships"],
  "OQE": ["oqe","olympic qualifying","olympic qualifier"],
  "CIS": ["cis","canadian interuniversity","u sports older name cis"],
  "U Sports": ["u sports","u-sports"],
  "Canadian Jrs": ["canadian juniors","canadian jrs","juniors","junior canada","canadian jr"],
  "Canadian U-18s": ["u-18","u18","canadian u-18","canadian u18","u18s","u-18s"],
  "Pacific-Asia": ["pacific asia","pacific-asian","pacific","asia","pacific asia curling"],
  "Jr Worlds": ["jr worlds","jr. worlds","junior worlds","junior world","jrworlds","world junior"],
  // also include some common alternate forms for UI-friendly labels
  "Grand Slam": ["grand slam","grand slams"],
  "Junior Worlds": ["jr worlds","junior worlds","junior world"]
};

// helper: normalize a string for comparisons: lowercase, remove punctuation, collapse whitespace
function normalizeStr(s){
  if(!s) return '';
  return String(s).toLowerCase().replace(/[^\w\s]/g,' ').replace(/\s+/g,' ').trim();
}

/* DOM refs */
const evalPos = document.getElementById('evalPos');
const endsLeftSelect = document.getElementById('endsLeftSelect');
const supportSlider = document.getElementById('supportSlider');
const supportVal = document.getElementById('supportVal');
const analyzeBtn = document.getElementById('analyzeBtn');
const resultsDiv = document.getElementById('results');
const statusDiv = document.getElementById('status');
const progressWrap = document.getElementById('progressWrap');
const progressBar = document.getElementById('progressBar');
const playerSelect = document.getElementById('playerSelect');
const playerDefaultsPanel = document.getElementById('playerDefaultsPanel');
const defaultsGrid = document.getElementById('defaultsGrid');
const toggleViewBtn = document.getElementById('toggleViewBtn');
const downloadBtn = document.getElementById('downloadBtn');
const genderSelect = document.getElementById('genderSelect');
const categorySelect = document.getElementById('categorySelect');
const startDateEl = document.getElementById('startDate');
const endDateEl = document.getElementById('endDate');
const constraintsDiv = document.getElementById('constraints');

/* init UI */
for(let i=1;i<=16;i++) evalPos.appendChild(new Option(i,i));
endsLeftSelect.appendChild(new Option('Any','Any',true,true));
for(let v=10; v>=0; v--) endsLeftSelect.appendChild(new Option(String(v), String(v)));
supportVal.textContent = supportSlider.value + '%';
supportSlider.addEventListener('input', ()=> supportVal.textContent = supportSlider.value + '%');

/* build shot cards */
for(let i=0;i<16;i++){
  const wrapper = document.createElement('div'); wrapper.className='task-card';
  wrapper.innerHTML = `<div class="task-title">Shot ${i+1}</div>
    <select data-index="${i}" class="taskSel" multiple size="4"></select>
    <div style="height:8px"></div>
    <select data-index="${i}" class="turnSel" multiple size="3"></select>`;
  constraintsDiv.appendChild(wrapper);
}
document.querySelectorAll('.taskSel').forEach(s=> { TASK_OPTIONS.forEach(t=> s.add(new Option(t,t))); s.value='Any'; });
document.querySelectorAll('.turnSel').forEach(s=> { TURN_OPTIONS.forEach(t=> s.add(new Option(t,t))); s.value='Any'; });

/* defaults grid */
const DEFAULT_TASKS = TASK_OPTIONS.filter(t=>t!=='Any');
DEFAULT_TASKS.forEach(task=>{
  const div = document.createElement('div'); div.style.background='linear-gradient(180deg,#fff,#fbfdff)'; div.style.padding='8px'; div.style.borderRadius='8px';
  div.innerHTML = `<div style="font-weight:700;margin-bottom:6px">${task}</div>
    <div style="display:flex;gap:8px;align-items:center"><label class="muted-xs" style="width:40px">CW</label><input data-task="${task}" data-turn="CW" class="defInput" placeholder="100" type="number" min="0" max="100" /></div>
    <div style="display:flex;gap:8px;align-items:center;margin-top:6px"><label class="muted-xs" style="width:40px">CCW</label><input data-task="${task}" data-turn="CCW" class="defInput" placeholder="100" type="number" min="0" max="100" /></div>`;
  defaultsGrid.appendChild(div);
});

/* CSV parsing (for players) */
function splitCSVLine(line){ const out=[]; let cur=''; let inQ=false; for(let i=0;i<line.length;i++){ const ch=line[i]; if(inQ){ if(ch==='\"'){ if(line[i+1]==='\"'){ cur+='"'; i++; } else inQ=false; } else cur+=ch; } else { if(ch===','){ out.push(cur); cur=''; } else if(ch==='"'){ inQ=true; } else cur+=ch; } } out.push(cur); return out; }
function parseCSV(text){ const lines=text.split(/\r?\n/).filter(l=>l.trim()!==''); if(lines.length===0) return {header:[],rows:[]}; const header = splitCSVLine(lines[0]).map(h=>h.trim()); const rows=[]; for(let i=1;i<lines.length;i++){ const cols=splitCSVLine(lines[i]); if(cols.length===0) continue; const obj={}; for(let j=0;j<header.length;j++) obj[header[j]] = cols[j]===undefined? '' : cols[j]; rows.push(obj);} return {header, rows}; }
function parsePercent(s){ if(s===null||s===undefined) return null; let t=String(s).trim(); if(!t || t.toUpperCase()==='N/A') return null; t=t.replace('%','').replace(/,/g,'').trim(); const n=Number(t); return isNaN(n)? null : n; }

/* ======== loadPlayersCSV (UPDATED to show count) ======== */
async function loadPlayersCSV(path='/data/players_stats_spreadsheet.csv'){
  try{
    const r = await fetch(path); if(!r.ok) throw new Error('not found'); const txt = await r.text();
    const parsed = parseCSV(txt); const headers = parsed.header; const rows = parsed.rows;
    const taskCols = {};
    headers.forEach(h=>{ const m = h.match(/^(.*)_(CW|CCW)$/i); if(m){ const t=m[1].trim(); const turn=m[2].toUpperCase(); taskCols[t] = taskCols[t] || {taskName:t, CW:null, CCW:null}; taskCols[t][turn] = h; } });
    playerStatsObj = {};
    rows.forEach(row=>{
      const name = row['Player'] || row['player'] || Object.values(row)[0]; if(!name) return;
      const entry = { Shots: row['Shots']||'', AVG_CW: parsePercent(row['AVG_CW']||''), AVG_CCW: parsePercent(row['AVG_CCW']||''), tasks:{} };
      Object.values(taskCols).forEach(tc=>{ const cw = tc.CW ? parsePercent(row[tc.CW]) : null; const ccw = tc.CCW ? parsePercent(row[tc.CCW]) : null; entry.tasks[tc.taskName] = {CW:cw, CCW:ccw}; });
      playerStatsObj[name] = entry;
    });

    // repopulate player select
    playerSelect.innerHTML = '<option value="">-- none --</option>';
    Object.keys(playerStatsObj).sort().forEach(p=> playerSelect.appendChild(new Option(p,p)));

    // ====== FIX: show number of players loaded ======
    const playerCount = Object.keys(playerStatsObj).length;
    statusDiv.textContent = (statusDiv.textContent || '') + ` â€¢ ${playerCount} players loaded`;
    // if we have a visible progress bar, append players loaded there too
    if(progressBar){
      progressBar.textContent = progressBar.textContent + ` â€¢ ${playerCount} players`;
    }
  } catch(e){
    console.warn('players csv failed', e);
  }
}

/* merge summaries with progress */
async function fetchAndMergeAll(){
  progressWrap.style.display = 'block'; mergedAll=[]; byYearMap={}; const total = AVAILABLE_SUMMARIES.length; let done=0;
  for(const path of AVAILABLE_SUMMARIES){
    try{ const r=await fetch(path); if(r.ok){ const arr = await r.json(); if(Array.isArray(arr)){ const year = path.split('/').pop().replace('summary_','').replace('.json',''); byYearMap[year]=arr; mergedAll = mergedAll.concat(arr); } } else console.warn('skip', path, r.status); }catch(err){ console.warn('fetch',path,err); }
    done++; const pct = Math.round((done/total)*100); progressBar.style.width = pct+'%'; progressBar.textContent = pct+'%';
    await new Promise(r=>setTimeout(r,30));
  }
  // now attempt to load players CSV and report count (loadPlayersCSV updates statusDiv)
  try{ await loadPlayersCSV('/data/players_stats_spreadsheet.csv'); }catch(e){ console.warn('player CSV load failed at end', e); }

  progressBar.style.width = '100%';
  const playersText = (playerStatsObj && Object.keys(playerStatsObj).length) ? ` â€¢ ${Object.keys(playerStatsObj).length} players` : '';
  progressBar.textContent = `Loaded ${mergedAll.length} ends` + playersText;
  statusDiv.textContent = `Loaded ${mergedAll.length} ends across ${Object.keys(byYearMap).length} files.` + (playersText || '');
}

/* defaults storage */
const DEFAULTS_KEY = 'curling_player_defaults_v1';
function loadDefaultsFromStorage(){ try{ const r=localStorage.getItem(DEFAULTS_KEY); return r? JSON.parse(r): {}; }catch(e){return{}} }
function readCurrentDefaults(){ const out={}; document.querySelectorAll('.defInput').forEach(inp=>{ const k=`${inp.dataset.task}||${inp.dataset.turn}`; const v = inp.value===''? null: Number(inp.value); out[k] = v===null||isNaN(v) ? null : Math.max(0,Math.min(100,v)); }); return { name: document.getElementById('defaultsName').value||'', values: out }; }
function applyDefaultsToUI(obj){ if(!obj) return; if(obj.name) document.getElementById('defaultsName').value = obj.name; document.querySelectorAll('.defInput').forEach(inp=>{ const k = `${inp.dataset.task}||${inp.dataset.turn}`; inp.value = (obj.values && obj.values[k] != null) ? String(obj.values[k]) : ''; }); }

document.getElementById('resetDefaultsBtn').addEventListener('click', ()=>{ if(!confirm('Reset defaults to blank (interpreted as 100%)?')) return; document.querySelectorAll('.defInput').forEach(i=>i.value=''); document.getElementById('defaultsName').value=''; saveDefaultsToStorage({}); statusDiv.textContent='Defaults reset.'; });

/* get active player percent (player selection takes precedence; otherwise defaults or 100) */
function getActivePlayerPct(task, turn){
  if(playerSelect.value && playerStatsObj && playerStatsObj[playerSelect.value]){
    const pd = playerStatsObj[playerSelect.value].tasks || {}; const te = pd[task];
    if(te){ const val = (turn==='CW') ? te.CW : te.CCW; if(val != null) return val; }
  }
  const stored = loadDefaultsFromStorage();
  const k = `${task}||${turn}`;
  if(stored && stored.values && stored.values[k] != null) return stored.values[k];
  return 100.0;
}

/* helpers */
function percentToHSLStatic(pct){ const v=Math.max(0,Math.min(100,Number(pct))); const hue=(v/100)*120; return `hsl(${hue},78%,45%)`; }
function pickTextColor(pct){ if(pct===null||pct===undefined) return '#333'; return (Number(pct) < 55) ? '#fff' : '#000'; }
function scoreBucket(n){ if(n==null) return null; if(n<=-3) return '-3+'; if(n===-2) return '-2'; if(n===-1) return '-1'; if(n===0) return '0'; if(n===1) return '1'; if(n===2) return '2'; if(n>=3) return '3+'; return null; }
function computeEstimateFromCounts(counts, total){ if(!counts || total===0) return null; let sum=0; for(let i=0;i<BUCKETS.length;i++) sum += BUCKET_VAL[BUCKETS[i]] * (counts[i]||0); return sum / total; }
function formatEstimate(x){ if(x==null) return 'N/A'; return (Math.round(x*10)/10).toFixed(1); }
function getSelectedValues(selectEl){ if(!selectEl) return []; const vals=[]; for(const opt of Array.from(selectEl.options)) if(opt.selected) vals.push(opt.value); return vals.length?vals:['Any']; }

/* constraints reading & matching (multi-select aware) */
function readConstraints(){ const tasks = document.querySelectorAll('.taskSel'); const turns = document.querySelectorAll('.turnSel'); const out=[]; for(let i=0;i<16;i++){ const taskVals = getSelectedValues(tasks[i]); const turnVals = getSelectedValues(turns[i]); out.push({task:taskVals, turn:turnVals}); } return out; }
function matchesConstraint(endRec, cons){
  for(let i=0;i<cons.length;i++){
    const c=cons[i]; const isTaskAny = c.task.includes('Any'); const isTurnAny = c.turn.includes('Any');
    if(isTaskAny && isTurnAny) continue;
    const shot = (endRec.shots||[]).find(s=>Number(s.shot_num)===i+1); if(!shot) return false;
    const shotTask = (shot.task||'').toString(); const shotTurn = (shot.turn||'').toString().toUpperCase();
    if(!isTaskAny){
      let matched=false;
      for(const opt of c.task){
        if(opt==='Any'){ matched=true; break; }
        if(opt.toLowerCase()==='guard'){ if(/guard/i.test(shotTask)){ matched=true; break; } }
        else if(opt.toLowerCase()==='front'){ if(/^front$/i.test(shotTask)){ matched=true; break; } }
        else { if(shotTask && shotTask.toLowerCase()===opt.toLowerCase()){ matched=true; break; } }
      }
      if(!matched) return false;
    }
    if(!isTurnAny){
      const selTurns = c.turn.map(x=>x.toUpperCase());
      if(!selTurns.includes(shotTurn)) return false;
    }
  }
  return true;
}

/* condensed toggle */
let condensed = true;
toggleViewBtn.addEventListener('click', ()=>{
  condensed = !condensed;
  toggleViewBtn.textContent = condensed? 'Expanded View' : 'Condensed View';
  if(condensed){
    if(!playerSelect.value) playerDefaultsPanel.style.display = 'none';
  } else {
    playerDefaultsPanel.style.display = 'block';
  }
  if(document.querySelector('#results table')) analyze();
});

/* when player selected: populate defaults inputs and reveal panel */
playerSelect.addEventListener('change', ()=>{
  const pname = playerSelect.value;
  if(!pname){
    if(condensed) playerDefaultsPanel.style.display = 'none';
    const stored = loadDefaultsFromStorage(); if(stored) applyDefaultsToUI(stored);
    return;
  }
  playerDefaultsPanel.style.display = 'block';
  const p = playerStatsObj && playerStatsObj[pname];
  if(!p){ document.getElementById('defaultsName').value = pname; document.querySelectorAll('.defInput').forEach(inp=> inp.value = ''); return; }
  document.getElementById('defaultsName').value = pname;
  document.querySelectorAll('.defInput').forEach(inp=>{
    const task = inp.dataset.task; const turn = inp.dataset.turn;
    const val = (p.tasks && p.tasks[task]) ? ((turn==='CW')? p.tasks[task].CW : p.tasks[task].CCW) : null;
    inp.value = val == null ? '' : String(val);
  });
});

/* analysis core (with category alias normalization) */
async function analyze(){
  const dataset = mergedAll;
  const cons = readConstraints();
  const evalShot = Number(evalPos.value || 1);
  const sd = startDateEl.value? new Date(startDateEl.value) : null;
  const ed = endDateEl.value? new Date(endDateEl.value) : null;
  const minSupport = Number(supportSlider.value);
  const endsSelected = getSelectedValues(endsLeftSelect); const endsIsAny = endsSelected.includes('Any');
  const genderSelected = getSelectedValues(genderSelect); const genderIsAny = genderSelected.includes('Any');

  /* --- inside analyze(): read selected categories (multi) --- */
  const categorySelected = getSelectedValues(categorySelect);
  const categoryIsAny = categorySelected.includes('Any') || categorySelected.length === 0;

  // build normalized alias list for selected categories (only once)
  let selectedCategoryAliases = null;
  if(!categoryIsAny){
    selectedCategoryAliases = [];
    for(const sel of categorySelected){
      const mapped = CATEGORY_ALIASES[sel] || CATEGORY_ALIASES[sel.trim()] || null;
      if(mapped && Array.isArray(mapped)){
        mapped.forEach(m => {
          const norm = normalizeStr(m);
          if(norm && !selectedCategoryAliases.includes(norm)) selectedCategoryAliases.push(norm);
        });
      } else {
        const norm = normalizeStr(sel);
        if(norm && !selectedCategoryAliases.includes(norm)) selectedCategoryAliases.push(norm);
      }
    }
  }

  const candidateTasks = TASK_OPTIONS.filter(t=>t!=='Any');
  const pairs=[]; candidateTasks.forEach(t=>['CW','CCW'].forEach(turn=> pairs.push({task:t, turn:turn})));
  const accum = {}; pairs.forEach(p=> accum[`${p.task}||${p.turn}`] = { total:0, counts: BUCKETS.map(()=>0) });

  let matchedEnds = 0;
  for(const endRec of dataset){
    if(sd || ed){ if(endRec.date){ const d=new Date(endRec.date); if(sd && d<sd) continue; if(ed && d>ed) continue; } }

    // ends filter
    if(!endsIsAny){ if(endRec.ends_remaining==null) continue; const er = Number(endRec.ends_remaining); if(!endsSelected.map(x=>Number(x)).includes(er)) continue; }

    // gender filter
    if(!genderIsAny){ const recGender = (endRec.gender||''); const ok = genderSelected.some(g => recGender && recGender.toString().toLowerCase().includes(g.toString().toLowerCase())); if(!ok) continue; }

    // category filter: use normalized aliases for robust matching
    if(!categoryIsAny){
      const recCatRaw = (endRec.category || '');
      const recCat = normalizeStr(recCatRaw);
      if(!recCat) continue;
      const okc = selectedCategoryAliases.some(alias => recCat.indexOf(alias) !== -1);
      if(!okc) continue;
    }

    if(!matchesConstraint(endRec, cons)) continue;

    matchedEnds++;
    const shot = (endRec.shots||[]).find(s=>Number(s.shot_num)===evalShot); if(!shot) continue;
    const shotTask = (shot.task||'').toString(); const shotTurn = (shot.turn||'').toString().toUpperCase();
    const signed = (endRec.signed_score == null) ? null : Number(endRec.signed_score);
    if(signed==null) continue;

    for(const p of pairs){
      let matchTask=false;
      if(p.task.toLowerCase()==='guard') matchTask = /guard/i.test(shotTask);
      else if(p.task.toLowerCase()==='front') matchTask = /^front$/i.test(shotTask);
      else matchTask = shotTask && shotTask.toLowerCase() === p.task.toLowerCase();
      if(!matchTask) continue;
      if(shotTurn !== p.turn) continue;
      const key = `${p.task}||${p.turn}`; const b = scoreBucket(signed); if(!b) continue;
      const idx = BUCKETS.indexOf(b); if(idx>=0){ accum[key].counts[idx] += 1; accum[key].total += 1; }
    }
  }

  // build rows (condensed combines turns)
  const rowsPre = [];
  if(condensed){
    for(const task of TASK_OPTIONS.filter(t=>t!=='Any')){
      const aCW = accum[`${task}||CW`] || {total:0, counts: BUCKETS.map(()=>0)};
      const aCCW = accum[`${task}||CCW`] || {total:0, counts: BUCKETS.map(()=>0)};
      const total = (aCW.total||0) + (aCCW.total||0);
      const counts = BUCKETS.map((_,i)=> (aCW.counts[i]||0) + (aCCW.counts[i]||0));
      rowsPre.push({task, turn:'BOTH', total, counts, parts:{cwTotal:aCW.total||0, ccwTotal:aCCW.total||0}});
    }
  } else {
    for(const [key,entry] of Object.entries(accum)){
      const total = entry.total || 0; const [task, turn] = key.split('||'); rowsPre.push({task, turn, total, counts: entry.counts});
    }
  }

  const rowsFiltered = [];
  rowsPre.forEach(r=>{ const supportPct = matchedEnds===0?0:(r.total / matchedEnds * 100); if(supportPct >= minSupport) rowsFiltered.push(Object.assign({}, r, { supportPct })); });
  rowsFiltered.sort((a,b)=> b.supportPct - a.supportPct);

  // dynamic scaling values (expanded)
  let bucketPctValues = [];
  if(!condensed){ rowsFiltered.forEach(r=>{ for(let i=0;i<r.counts.length;i++){ const pct = r.total===0?null:(r.counts[i]/r.total*100); if(pct!=null) bucketPctValues.push(pct); } }); }
  let globalMin = bucketPctValues.length? Math.min(...bucketPctValues):0;
  let globalMax = bucketPctValues.length? Math.max(...bucketPctValues):1;
  if(globalMin === globalMax){ globalMin=0; globalMax = globalMin + 1; }

  // compute estimates & player-adjusted
  let maxEstimate = -Infinity, maxPlayerAdj = -Infinity;
  rowsFiltered.forEach(r=>{
    r.estimate = computeEstimateFromCounts(r.counts, r.total);
    if(r.estimate!=null && r.estimate > maxEstimate) maxEstimate = r.estimate;
    // player %
    let playerPct = null;
    if(playerSelect.value && playerStatsObj && playerStatsObj[playerSelect.value]){
      const pd = playerStatsObj[playerSelect.value].tasks || {};
      if(condensed){
        const pdEntry = pd[r.task] || {}; const cw = pdEntry.CW, ccw = pdEntry.CCW;
        if(cw != null && ccw != null) playerPct = (cw + ccw) / 2.0;
        else if(cw != null) playerPct = cw;
        else if(ccw != null) playerPct = ccw;
      } else {
        const pdEntry = pd[r.task] || {}; playerPct = (r.turn === 'CW') ? pdEntry.CW : pdEntry.CCW;
      }
    } else {
      if(condensed){
        const cw = getActivePlayerPct(r.task, 'CW'); const ccw = getActivePlayerPct(r.task, 'CCW');
        if(cw!=null && ccw!=null) playerPct = (cw+ccw)/2.0; else playerPct = cw!=null?cw:(ccw!=null?ccw:100);
      } else {
        playerPct = getActivePlayerPct(r.task, r.turn);
      }
    }
    r.playerPct = playerPct;
    r.playerAdj = (playerPct==null || r.estimate==null) ? null : (r.estimate * (playerPct/100.0));
    if(r.playerAdj!=null && r.playerAdj > maxPlayerAdj) maxPlayerAdj = r.playerAdj;
  });

  // render
  if(rowsFiltered.length === 0){
    resultsDiv.innerHTML = `<div class="muted-xs" style="padding:10px">No rows match current filters (min support ${minSupport}%).</div>`;
    statusDiv.textContent = `Matched ${matchedEnds} ends â€” 0 rows pass`;
    return;
  }

  const table = document.createElement('table');
  const thead = document.createElement('thead');
  if(condensed){
    thead.innerHTML = `<tr><th>Shot</th><th>Estimate</th><th>Popularity</th><th>Player %</th><th>Player-Adj</th></tr>`;
  } else {
    thead.innerHTML = `<tr><th>Shot</th><th>Turn</th>${BUCKETS.map(b=>`<th>${b}</th>`).join('')}<th>Estimate</th><th>Popularity</th><th>Player %</th><th>Player-Adj</th></tr>`;
  }
  table.appendChild(thead);
  const tbody = document.createElement('tbody');

  rowsFiltered.forEach(r=>{
    const tr = document.createElement('tr');
    if(condensed){
      const estimateDisp = r.estimate==null?'N/A':formatEstimate(r.estimate);
      const playerPctDisp = r.playerPct==null?'N/A':(r.playerPct.toFixed(1)+'%');
      const playerAdjDisp = r.playerAdj==null?'':(Math.round(r.playerAdj*10)/10).toFixed(1);
      // apply highlight cell classes
      const estClass = (r.estimate===maxEstimate) ? 'cell-best-est' : '';
      const playerClass = (r.playerAdj===maxPlayerAdj) ? 'cell-best-player' : '';
      tr.innerHTML = `<td>${r.task}</td><td class="center ${estClass}">${estimateDisp}</td><td class="center">${r.supportPct.toFixed(2)}%</td><td class="center" data-pct="${r.playerPct==null?'':r.playerPct}">${playerPctDisp}</td><td class="center ${playerClass}">${playerAdjDisp}</td>`;
      const pcell = tr.querySelector('td[data-pct]');
      if(pcell){
        const pctAttr = pcell.getAttribute('data-pct');
        if(!pctAttr){ pcell.style.background='#f6f6f6'; pcell.style.color='#666'; }
        else { const num = Number(pctAttr); pcell.style.background = percentToHSLStatic(num); pcell.style.color = pickTextColor(num); pcell.style.borderRadius='6px'; }
      }
    } else {
      let html = `<td>${r.task}</td><td>${r.turn}</td>`;
      for(let i=0;i<r.counts.length;i++){
        const cnt = r.counts[i]; const pct = r.total===0 ? null : (r.counts[i] / r.total * 100);
        const disp = pct==null? 'N/A' : (pct.toFixed(1)+'%');
        let styleAttr = '';
        if(pct==null) styleAttr = 'style="background:#f6f6f6;color:#666"';
        else {
          const norm = (pct - globalMin) / (globalMax - globalMin || 1);
          const hue = (norm * 120);
          const bg = `hsl(${hue},78%,45%)`;
          const text = (pct < 55) ? '#fff' : '#000';
          styleAttr = `style="background:${bg};color:${text};border-radius:6px"`;
        }
        html += `<td ${styleAttr} data-pct="${pct==null?'':pct.toFixed(1)}">${disp}</td>`;
      }
      const estClass = (r.estimate===maxEstimate) ? 'cell-best-est' : '';
      const playerClass = (r.playerAdj===maxPlayerAdj) ? 'cell-best-player' : '';
      const estimateDisp = r.estimate==null? 'N/A' : formatEstimate(r.estimate);
      const playerPctDisp = r.playerPct==null? 'N/A' : (r.playerPct.toFixed(1) + '%');
      const playerAdjDisp = r.playerAdj==null? '' : (Math.round(r.playerAdj*10)/10).toFixed(1);
      html += `<td class="center ${estClass}">${estimateDisp}</td><td class="center">${r.supportPct.toFixed(2)}%</td><td class="center" data-pct="${r.playerPct==null?'':r.playerPct}">${playerPctDisp}</td><td class="center ${playerClass}">${playerAdjDisp}</td>`;
      tr.innerHTML = html;
      const pcell = tr.querySelector('td[data-pct]');
      if(pcell){
        const pctAttr = pcell.getAttribute('data-pct');
        if(!pctAttr){ pcell.style.background='#f6f6f6'; pcell.style.color='#666'; }
        else { const num = Number(pctAttr); pcell.style.background = percentToHSLStatic(num); pcell.style.color = pickTextColor(num); pcell.style.borderRadius='6px'; }
      }
    }
    tbody.appendChild(tr);
  });

  table.appendChild(tbody);
  resultsDiv.innerHTML = '';
  resultsDiv.appendChild(table);
  statusDiv.textContent = `Matched ${matchedEnds} ends. Showing ${rowsFiltered.length} rows (min support ${minSupport}%).`;
}

/* download CSV */
downloadBtn.addEventListener('click', ()=>{ const tbl = document.querySelector('#results table'); if(!tbl){ alert('No results'); return; } const rows=[]; rows.push(Array.from(tbl.tHead.rows[0].cells).map(c=>c.textContent)); Array.from(tbl.tBodies[0].rows).forEach(r=> rows.push(Array.from(r.cells).map(c=>c.textContent.replace('%','')))); const csv = rows.map(r => r.map(c=>'"'+String(c).replace(/"/g,'""')+'"').join(',')).join('\n'); const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'score_outcome_player_adjusted.csv'; a.click(); URL.revokeObjectURL(url); });

/* when page loads */
fetchAndMergeAll().then(()=>{
  try{ const st = loadDefaultsFromStorage(); if(st) applyDefaultsToUI(st); }catch(e){}
  // by default condensed and hide playerDefaultsPanel
  playerDefaultsPanel.style.display = 'none';
});

/* wire analyze button */
analyzeBtn.addEventListener('click', analyze);
</script>
</body>
</html>
